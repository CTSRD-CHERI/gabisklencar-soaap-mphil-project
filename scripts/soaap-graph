#!/usr/bin/env python

import argparse
import itertools
import json
import sys

import callgraph
import dot
import soaap


args = argparse.ArgumentParser()
args.add_argument('filename')
args.add_argument('-o', '--output', default = '-')
args.add_argument('-a', '--analysis', default = 'vulnerability_warning',
                  help = ("Which SOAAP analysis output to parse. Options are: "
                          + ', '.join(soaap.analyses.keys()) + '.'))
args.add_argument('-c', '--cluster-by', default = '',
                  help = ("Cluster functions in the output graph by"
                          + " 'filename', 'namespace' or 'sandbox',"
                          + " or, using a comma-separated list, by"
                          + " several of these."))
args.add_argument('-s', '--simplify', action = 'store_true')

args = args.parse_args()

f = open(args.filename, 'r')
out = open(args.output, 'w') if args.output != '-' else sys.stdout

data = json.load(f)['soaap']
(functions, calls) = soaap.parse(data, args.analysis)

#
# How do we want to group nodes into subgraphs?
#
if args.cluster_by == '':
    # Put everything together in one big cluster called 'Callgraph'
    cluster_key = lambda node: 'Callgraph'

else:
    cluster_by = args.cluster_by.split(',')
    keys = []

    if 'filename' in cluster_by:
        keys.append(lambda fn: 'filename: %s' % fn.filename())

    if 'namespace' in cluster_by:
        keys.append(lambda fn: 'namespace: %s' % fn.namespace())

    if 'sandbox' in cluster_by:
        keys.append(lambda fn: 'sandbox: %s' % fn.sandbox())

    assert len(keys) == len(cluster_by), '%s -> %s' % (cluster_by, keys)

    def cluster_key(node):
        return ', '.join([ str(k(node)) for k in keys ])


if args.simplify:
    (functions, calls) = callgraph.simplify(functions, calls, cluster_key)


#
# Convert call graph into GraphViz .dot format.
#
out.write('''
digraph {
    node [ fontname = "Inconsolata" ];
    edge [ fontname = "Avenir" ];

    labeljust = "l";
    labelloc = "b";
    rankdir = "BT";

''')

clusters = {}
functions = sorted(functions, key = cluster_key)

for (cluster, group) in itertools.groupby(functions, key = cluster_key):
    name = 'cluster_%d' % (len(clusters) + 1)
    clusters[cluster] = name

    out.write('    subgraph %s {\n' % name)
    out.write('        bgcolor = "#cccccc33";\n')
    out.write('        label = "%s";\n' % cluster)
    out.write('\n')

    for node in group:
        if node.cve and node.sandbox_name:
            color = '#ffff66cc'

        elif node.cve:
            color = '#ff9999cc'

        elif node.owner:
            color = '#ff99ffcc'

        elif node.sandbox_name:
            color = '#99ff9999'

        else:
            color = ''

        attributes = dot.attribute_list({
            'fillcolor': color,
            'label': node.fn[:80],
            'style': 'filled',
        })

        out.write('        "%s" %s;\n' % (node.name(), attributes))

    out.write('    }\n\n')

for ((source, dest), weight) in calls.items():
    assert source in functions
    assert dest in functions
    assert weight > 0

    label = ('' if args.simplify else
             '%s:%d' % (source.location['file'], source.location['line']))

    attrs = dot.attribute_list({
        'label': label,
        'lhead': clusters[cluster_key(source)],
        'ltail': clusters[cluster_key(dest)],
        'penwidth': weight,
        'weight': weight,
    })

    out.write('    "%s" -> "%s" %s\n' % (source.name(), dest.name(), attrs))

out.write('}\n')
