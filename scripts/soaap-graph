#!/usr/bin/env python

import argparse
import collections
import itertools
import json
import re
import sys


class Function:
    """
    Nodes in the callgraph are functions and methods.
    """

    def __init__(self, fn, sandbox, location, cve = None):
        self.parameters = fn[ fn.find('(') + 1 : fn.find(')') + 1][:-1]
        fn = fn.split('(')[0]

        # Ignore template parameters.
        fn = re.sub(r'<.*>', '', fn)

        components = fn.split('::')
        self.namespace_ = '::'.join(components[:-2])
        self.fn = '::'.join(components[-2:])

        self.sandbox_name = sandbox
        self.location = location
        assert location is not None
        if 'file' not in self.location:
            raise ValueError, self.location
        assert 'file' in self.location
        self.cve = cve

        self.callers = set()
        self.callees = set()

    def filename(self):
        if not self.location:
            return ''

        return self.location['file']

    def fqname(self):
        """ Fully-qualified function name """
        return '::'.join(( self.namespace_, self.fn ))

    def label(self):
        return self.fn

    def name(self):
        return self.fn + (' <<%s>>' % self.sandbox_name if self.sandbox_name else '')

    def namespace(self):
        return self.namespace_

    def sandbox(self):
        return self.sandbox_name

    def __str__(self):
        return '%s (%s:%d)' % (self.name(), self.filename(), self.location['line'])


def dotattrs(attrs):
    """
    Convert a Python dictionary into a dot-style attribute list:
    [ foo = "x", bar = "y" ]
    """

    return (
        '[ '
        + ', '.join([
                '%s = "%s"' % i for i in attrs.items()
            ])
        + ' ]'
    )



#
# Parse command-line arguments and open the JSON input.
#
args = argparse.ArgumentParser()
args.add_argument('filename')
args.add_argument('-o', '--output', default = '-')

args = args.parse_args()

out = open(args.output, 'w') if args.output != '-' else sys.stdout

f = open(args.filename, 'r')
soaap = json.load(f)['soaap']


#
# Parse vulnerability information from SOAAP.
#
functions = {}
calls = collections.defaultdict(int)

for vuln in soaap['vulnerability_warning']:
    fn = vuln['function']
    sandbox = vuln['sandbox']
    if sandbox == '"none"': sandbox = None

    key = (fn, sandbox)
    if key in functions:
        callee = functions[key]

    else:
        callee = functions[key] = Function(
            fn, sandbox, location = vuln['location'], cve = vuln['cve'])


    for t in vuln['trace']:
        key = (t['function'], sandbox)

        if key in functions:
            caller = functions[key]

        else:
            caller = functions[key] = Function(
                fn = t['function'],
                sandbox = sandbox,
                location = t['location'] if 'location' in t else t
            )

        callee.callers.add(caller)
        caller.callees.add(callee)
        calls[(caller, callee)] += 1

        callee = caller



functions = functions.values()
cluster_key = lambda node: node.filename()


#
# Convert call graph into GraphViz .dot format.
#
out.write('''
digraph {
    node [ fontname = "Inconsolata" ];
    edge [ fontname = "Avenir" ];

    labeljust = "l";
    labelloc = "b";
    rankdir = "BT";

''')

clusters = {}
functions = sorted(functions, key = cluster_key)

for (cluster, group) in itertools.groupby(functions, key = cluster_key):
    name = 'cluster_%d' % (len(clusters) + 1)
    clusters[cluster] = name

    out.write('    subgraph %s {\n' % name)
    out.write('        bgcolor = "#cccccc33";\n')
    out.write('        label = "%s";\n' % cluster)
    out.write('\n')

    for node in group:
        if node.cve and node.sandbox_name:
            color = '#ffff66cc'

        elif node.cve:
            color = '#ff9999cc'

        elif node.sandbox_name:
            color = '#99ff9999'

        else:
            color = ''

        attributes = dotattrs({
            'fillcolor': color,
            'label': node.fn[:80],
            'style': 'filled',
        })

        out.write('        "%s" %s;\n' % (node.name(), attributes))

    out.write('    }\n\n')

for ((source, dest), weight) in calls.items():
    if weight == 0:
        continue

    attrs = dotattrs({
        'label': '%s:%d' % (source.location['file'], source.location['line']),
        'lhead': clusters[cluster_key(source)],
        'ltail': clusters[cluster_key(dest)],
        'penwidth': weight,
        'weight': weight,
    })

    out.write('    "%s" -> "%s" %s\n' % (source.name(), dest.name(), attrs))

out.write('}\n')
