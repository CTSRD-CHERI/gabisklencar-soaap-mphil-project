#ifndef SOAAP_REPORT_IR_VULNERABILITY_H
#define SOAAP_REPORT_IR_VULNERABILITY_H

#include "Common/Sandbox.h"
#include "Common/Typedefs.h"
#include "Report/IR/Element.h"
#include "Report/IR/SourceLocation.h"
#include "Report/Render/Renderer.h"

#include "llvm/IR/GlobalVariable.h"
#include "llvm/IR/Function.h"

#include <map>
#include <string>
#include <vector>

using namespace llvm;
using namespace std;

namespace soaap {

  enum VariableRight {
    READ, WRITE
  };

  enum VariableType {
    LOCAL,
    GLOBAL,
    STRUCT_MEMBER
  };

  class Vulnerability : public Element {
    public:
      Vulnerability(Function* F, Sandbox* sbox, bool l, bool v, StringSet c)
        : loc(SourceLocation(F)), sandbox(sbox), limitedRights(l), vulnVendor(v), cves(c) { }
      virtual void render(Renderer* r);
      virtual void addToGlobals(GlobalVariable* g, vector<VariableRight>& rights);
      virtual void addToPrivates(Value* v, VariableType type);
      virtual void setCapabilities(ValueFunctionSetMap& caps);
      virtual void setCallgates(FunctionVector& cgates);
      virtual void setStack(InstTrace& instStack);
      virtual SourceLocation getLocation() { return loc; }
      virtual bool isVulnVendorLoc() { return vulnVendor; }
      virtual bool isSandboxed() { return sandbox != nullptr; }
      virtual bool leaksLimitedRights() { return limitedRights; }
      virtual Sandbox* getSandbox() { return sandbox; }
      virtual StringSet getCVEs() { return cves; }
      virtual vector<SourceLocation> getStack() { return stack; }
      virtual map<GlobalVariable*, vector<VariableRight> > getGlobals() { return globals; }
      virtual ValueFunctionSetMap getCapabilities() { return capabilities; }
      virtual map<Value*, VariableType> getPrivates() { return privates; }
      virtual FunctionVector getCallgates() { return callgates; }

    protected:
      SourceLocation loc;
      Sandbox* sandbox;
      bool vulnVendor;
      bool limitedRights;
      StringSet cves;
      vector<SourceLocation> stack;
      map<GlobalVariable*, vector<VariableRight> > globals;
      ValueFunctionSetMap capabilities;
      map<Value*, VariableType> privates;
      FunctionVector callgates;
  };

}
#endif
