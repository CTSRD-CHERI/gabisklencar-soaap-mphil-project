#include "Analysis/VulnerabilityAnalysis.h"
#include "Util/PrettyPrinters.h"
#include "soaap.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"

using namespace soaap;

void VulnerabilityAnalysis::doAnalysis(Module& M, SandboxVector& sandboxes) {
  findPastVulnerabilityAnnotations(M);
  findVulnerableVendorFuncs(M);
  checkLeakedRights(M, sandboxes);
}

void VulnerabilityAnalysis::findPastVulnerabilityAnnotations(Module& M) {
  // Find all annotated code blocks. Note, we do this by inserting calls to 
  // the function __soaap_past_vulnerability_at_point. This function is declared
  // static to avoid linking problems when linking multiple modules. However,
  // as a result of this, a number may be appended to its name to make it unique.
  // We therefore have to search through all the functions in M and find those
  // that start with __soaap_past_vulnerability_at_point
  string pastVulnFuncBaseName = "__soaap_past_vulnerability_at_point";
  for (Function& F : M.getFunctionList()) {
    if (F.getName().startswith(pastVulnFuncBaseName)) {
      dbgs() << "   Found " << F.getName() << " function\n";
      for (User* U : F.users()) {
        if (CallInst* call = dyn_cast<CallInst>(U)) {
          //call->dump();
          Function* enclosingFunc = call->getParent()->getParent();
          pastVulnAnnotatedPoints.push_back(call);
          if (GlobalVariable* CVEGlobal = dyn_cast<GlobalVariable>(call->getArgOperand(0)->stripPointerCasts())) {
            ConstantDataArray* CVEGlobalArr = dyn_cast<ConstantDataArray>(CVEGlobal->getInitializer());
            StringRef CVE = CVEGlobalArr->getAsCString();
            funcToCVEs[enclosingFunc].push_back(CVE);
            vulnerableFuncs.push_back(enclosingFunc);
          }
        }
      }
    }
  }

  // Find all annotated functions
  GlobalVariable* lga = M.getNamedGlobal("llvm.global.annotations");
  if (lga != NULL) {
    ConstantArray* lgaArray = dyn_cast<ConstantArray>(lga->getInitializer()->stripPointerCasts());
    for (User::op_iterator i=lgaArray->op_begin(), e = lgaArray->op_end(); e!=i; i++) {
      ConstantStruct* lgaArrayElement = dyn_cast<ConstantStruct>(i->get());

      // get the annotation value first
      GlobalVariable* annotationStrVar = dyn_cast<GlobalVariable>(lgaArrayElement->getOperand(1)->stripPointerCasts());
      ConstantDataArray* annotationStrArray = dyn_cast<ConstantDataArray>(annotationStrVar->getInitializer());
      StringRef annotationStrArrayCString = annotationStrArray->getAsCString();

      GlobalValue* annotatedVal = dyn_cast<GlobalValue>(lgaArrayElement->getOperand(0)->stripPointerCasts());
      if (isa<Function>(annotatedVal)) {
        Function* annotatedFunc = dyn_cast<Function>(annotatedVal);
        if (annotationStrArrayCString.startswith(PAST_VULNERABILITY)) {
          dbgs() << "   Found annotated function " << annotatedFunc->getName() << "\n";
          pastVulnAnnotatedFuncs.push_back(annotatedFunc);
          StringRef CVE = annotationStrArrayCString.substr(strlen(PAST_VULNERABILITY)+1);
          funcToCVEs[annotatedFunc].push_back(CVE);
          vulnerableFuncs.push_back(annotatedFunc);
        }
      }
    }
  }
}

void VulnerabilityAnalysis::findVulnerableVendorFuncs(Module& M) {
  // provenance is recorded in compilation units with a variable called
  // __soaap_provenance_var. This variable has hidden visibility so that
  // the linker doesn't complain when linking multiple compilation units
  // together.
  string provenanceVarBaseName = "__soaap_provenance";
  SmallVector<DICompileUnit,16> CUs;
  if (NamedMDNode* CUMDNodes = M.getNamedMetadata("llvm.dbg.cu")) {
    for(unsigned i = 0, e = CUMDNodes->getNumOperands(); i != e; i++) {
      MDNode* CUMDNode = CUMDNodes->getOperand(i);
      DICompileUnit CU(CUMDNode);
      CUs.push_back(CU);
    }
  }

  // each __soaap_provenance global var is defined in exactly one CU,
  // so remove a CU from CUs once it has be attributed to a var
  for (GlobalVariable& G : M.getGlobalList()) {
    if (G.getName().startswith(provenanceVarBaseName)) {
      dbgs() << "Found global variable " << G.getName() << "\n";
      GlobalVariable* provenanceStrVar = dyn_cast<GlobalVariable>(G.getInitializer()->stripPointerCasts());
      ConstantDataArray* provenanceArr = dyn_cast<ConstantDataArray>(provenanceStrVar->getInitializer());
      StringRef provenanceStr = provenanceArr->getAsCString(); // getAsString adds '\0' as an additional character
      dbgs() << "  Provenance: " << provenanceStr << "\n";

      if (find(vulnerableVendors.begin(), vulnerableVendors.end(), provenanceStr) != vulnerableVendors.end()) {
        outs() << "   " << provenanceStr << " is a vulnerable vendor\n";
        // Find out what the containing compilation unit and all its functions
        for(unsigned i = 0, ei = CUs.size(); i != ei; i++) {
          DICompileUnit CU = CUs[i];
          DIArray CUGlobals = CU.getGlobalVariables();
          for (unsigned j = 0, ej = CUGlobals.getNumElements(); j != ej; j++) {
            DIGlobalVariable CUGlobal = static_cast<DIGlobalVariable>(CUGlobals.getElement(j));
            if (CUGlobal.getGlobal() == &G) {
              outs() << "    Found containing compile unit for " << G.getName() << ", list functions:\n";
              DIArray CUSubs = CU.getSubprograms();
              for (unsigned k = 0, ek = CUSubs.getNumElements(); k != ek; k++) {
                DISubprogram CUSub = static_cast<DISubprogram>(CUSubs.getElement(k));
                if (Function* CUFunc = CUSub.getFunction()) {
                  outs() << "      " << CUFunc->getName() << "()\n";
                  // record that CUFunc is vulnerable
                  if (find(vulnerableVendorFuncs.begin(), vulnerableVendorFuncs.end(), CUFunc) == vulnerableVendorFuncs.end()) {
                    vulnerableVendorFuncs.push_back(CUFunc);
                    vulnerableFuncs.push_back(CUFunc);
                  }
                }
              }
              CUs.erase(CUs.begin()+i); // remove CU from CUs
              goto outerloop;
            }
          }
        }
        outerloop:
        ;
      }
    }
  }
}

void VulnerabilityAnalysis::checkLeakedRights(Module& M, SandboxVector& sandboxes) {

  for (Function* F : vulnerableFuncs) {
    for (Sandbox* S : sandboxes) {
      FunctionVector sandboxedFuncs = S->getFunctions();
      Function* entryPoint = S->getEntryPoint();
      if (S->containsFunction(F)) {
        outs() << "\n";
        map<Function*,StringVector>::iterator it = funcToCVEs.find(F);
        if (it == funcToCVEs.end()) {
          // vulnerable vendor func
          outs() << " *** Sandboxed function \"" << F->getName() << "\" is from a vulnerable vendor.\n";
          outs() << " *** A vulnerability here would not grant ambient authority to the attacker but would leak the following restricted rights:\n"     ;
        }
        else {
          // func with past vulnerabilities
          StringVector CVEs = it->second;
          outs() << " *** Sandboxed function \"" << F->getName() << "\" has past-vulnerability annotations for \"" << stringifyStringVector(CVEs) << "\".\n";
          outs() << " *** Another vulnerability here would not grant ambient authority to the attacker but would leak the following restricted rights:\n"     ;
        }

        // F may run in a sandbox
        // find out what was passed into the sandbox (shared global variables, file descriptors)
        DEBUG(dbgs() << "Checking leaking of global variables\n");
        GlobalVariableIntMap varToPerms = S->getGlobalVarPerms();
        for (pair<GlobalVariable*,int> varPermPair : varToPerms) {
          GlobalVariable* G = varPermPair.first;
          int varPerms = varPermPair.second;
          StringRef varPermsStr = "";
          if (varPerms == (VAR_READ_MASK | VAR_WRITE_MASK)) {
            varPermsStr = "Read and write";
          }
          else if (varPerms & VAR_READ_MASK) {
            varPermsStr = "Read";
          }
          else if (varPerms) {
            varPermsStr = "Write";
          }
          if (varPermsStr != "") {
            outs () << " +++ " << varPermsStr << " access to global variable \"" << G->getName() << "\"\n";
          }
        }
        
        DEBUG(dbgs() << "Checking leaking of capabilities\n");
        ValueIntMap caps = S->getCapabilities();
        for (pair<const Value*,int> cap : caps) {
          const Argument* capArg = dyn_cast<const Argument>(cap.first);
          int capPerms = cap.second;
          StringRef capPermsStr = "";
          if (capPerms == (FD_READ_MASK | FD_WRITE_MASK)) {
            capPermsStr = "Read and write";
          }
          else if (capPerms & FD_READ_MASK) {
            capPermsStr = "Read";
          }
          else if (capPerms) {
            capPermsStr = "Write";
          }
          if (capPermsStr != "") {
            outs() << " +++ " << capPermsStr << " access to file descriptor \"" << capArg->getName() << "\" passed into sandbox entrypoint \"" << entryPoint->getName() << "\"\n";
          }
        }

        DEBUG(outs() << "TODO: Check callgates\n");

        DEBUG(outs() << "TODO: Check sandbox-private data\n");

        DEBUG(outs() << "TODO: Check classified data\n");
      }
    }
    if (find(privilegedFuncs.begin(), privilegedFuncs.end(), F) != privilegedFuncs.end()) {
      // F may run with ambient authority
      outs() << "\n";
      map<Function*,StringVector>::iterator it = funcToCVEs.find(F);
      if (it == funcToCVEs.end()) {
        outs() << " *** Function \"" << F->getName() << "\" is from a vulnerable vendor.\n";
        outs() << " *** A vulnerability here would leak ambient authority to the attacker including full\n";
        outs() << " *** network and file system access.\n"; 
      }
      else {
        StringVector CVEs = it->second;
        outs() << " *** Function \"" << F->getName() << "\" has past-vulnerability annotations for \"" << stringifyStringVector(CVEs) << "\".\n";
        outs() << " *** Another vulnerability here would leak ambient authority to the attacker including full\n";
        outs() << " *** network and file system access.\n"; 
      }
      outs() << " Possible trace:\n";
      PrettyPrinters::ppPrivilegedPathToFunction(F, M);
      outs() << "\n\n";
    }
  }

}

string VulnerabilityAnalysis::stringifyStringVector(StringVector vec) {
  string str = "[";
  bool first = true;
  for (string s : vec) {
    if (!first) 
      str += ",";
    str += s;
    first = false;
  }
  str += "]";
  return str;
}
