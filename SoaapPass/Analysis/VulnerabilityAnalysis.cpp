#include "Analysis/VulnerabilityAnalysis.h"
#include "Utils/PrettyPrinters.h"
#include "soaap.h"
#include "llvm/DebugInfo.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"

using namespace soaap;

void VulnerabilityAnalysis::doAnalysis(Module& M, SandboxVector& sandboxes) {
  findPastVulnerabilityAnnotations(M);
  findVulnerableVendorFuncs(M);
  checkLeakedRights(M, sandboxes);
}

void VulnerabilityAnalysis::findPastVulnerabilityAnnotations(Module& M) {
  // Find all annotated code blocks. Note, we do this by inserting calls to 
  // the function __soaap_past_vulnerability_at_point. This function is declared
  // static to avoid linking problems when linking multiple modules. However,
  // as a result of this, a number may be appended to its name to make it unique.
  // We therefore have to search through all the functions in M and find those
  // that start with __soaap_past_vulnerability_at_point
  string pastVulnFuncBaseName = "__soaap_past_vulnerability_at_point";
  for (Function& F : M.getFunctionList()) {
    if (F.getName().startswith(pastVulnFuncBaseName)) {
      dbgs() << "   Found " << F.getName() << " function\n";
      for (User::use_iterator u = F.use_begin(), e = F.use_end(); e!=u; u++) {
        if (CallInst* call = dyn_cast<CallInst>(u.getUse().getUser())) {
          //call->dump();
          pastVulnAnnotatedPoints.push_back(call);
        }
      }
    }
  }

  // Find all annotated functions
  GlobalVariable* lga = M.getNamedGlobal("llvm.global.annotations");
  if (lga != NULL) {
    ConstantArray* lgaArray = dyn_cast<ConstantArray>(lga->getInitializer()->stripPointerCasts());
    for (User::op_iterator i=lgaArray->op_begin(), e = lgaArray->op_end(); e!=i; i++) {
      ConstantStruct* lgaArrayElement = dyn_cast<ConstantStruct>(i->get());

      // get the annotation value first
      GlobalVariable* annotationStrVar = dyn_cast<GlobalVariable>(lgaArrayElement->getOperand(1)->stripPointerCasts());
      ConstantDataArray* annotationStrArray = dyn_cast<ConstantDataArray>(annotationStrVar->getInitializer());
      StringRef annotationStrArrayCString = annotationStrArray->getAsCString();

      GlobalValue* annotatedVal = dyn_cast<GlobalValue>(lgaArrayElement->getOperand(0)->stripPointerCasts());
      if (isa<Function>(annotatedVal)) {
        Function* annotatedFunc = dyn_cast<Function>(annotatedVal);
        if (annotationStrArrayCString.startswith(PAST_VULNERABILITY)) {
          dbgs() << "   Found annotated function " << annotatedFunc->getName() << "\n";
          pastVulnAnnotatedFuncs.push_back(annotatedFunc);
          pastVulnAnnotatedFuncToCVE[annotatedFunc] = annotationStrArrayCString.substr(strlen(PAST_VULNERABILITY)+1);
        }
      }
    }
  }
}

void VulnerabilityAnalysis::findVulnerableVendorFuncs(Module& M) {
  // provenance is recorded in compilation units with a variable called
  // __soaap_provenance_var. This variable has hidden visibility so that
  // the linker doesn't complain when linking multiple compilation units
  // together.
  string provenanceVarBaseName = "__soaap_provenance";
  SmallVector<DICompileUnit,16> CUs;
  if (NamedMDNode* CUMDNodes = M.getNamedMetadata("llvm.dbg.cu")) {
    for(unsigned i = 0, e = CUMDNodes->getNumOperands(); i != e; i++) {
      MDNode* CUMDNode = CUMDNodes->getOperand(i);
      DICompileUnit CU(CUMDNode);
      CUs.push_back(CU);
    }
  }

  // each __soaap_provenance global var is defined in exactly one CU,
  // so remove a CU from CUs once it has be attributed to a var
  for (GlobalVariable& G : M.getGlobalList()) {
    if (G.getName().startswith(provenanceVarBaseName)) {
      dbgs() << "Found global variable " << G.getName() << "\n";
      GlobalVariable* provenanceStrVar = dyn_cast<GlobalVariable>(G.getInitializer()->stripPointerCasts());
      ConstantDataArray* provenanceArr = dyn_cast<ConstantDataArray>(provenanceStrVar->getInitializer());
      StringRef provenanceStr = provenanceArr->getAsCString(); // getAsString adds '\0' as an additional character
      dbgs() << "  Provenance: " << provenanceStr << "\n";

      if (find(vulnerableVendors.begin(), vulnerableVendors.end(), provenanceStr) != vulnerableVendors.end()) {
        outs() << "   " << provenanceStr << " is a vulnerable vendor\n";
        // Find out what the containing compilation unit and all its functions
        for(unsigned i = 0, ei = CUs.size(); i != ei; i++) {
          DICompileUnit CU = CUs[i];
          DIArray CUGlobals = CU.getGlobalVariables();
          for (unsigned j = 0, ej = CUGlobals.getNumElements(); j != ej; j++) {
            DIGlobalVariable CUGlobal = static_cast<DIGlobalVariable>(CUGlobals.getElement(j));
            if (CUGlobal.getGlobal() == &G) {
              outs() << "    Found containing compile unit for " << G.getName() << ", list functions:\n";
              DIArray CUSubs = CU.getSubprograms();
              for (unsigned k = 0, ek = CUSubs.getNumElements(); k != ek; k++) {
                DISubprogram CUSub = static_cast<DISubprogram>(CUSubs.getElement(k));
                if (Function* CUFunc = CUSub.getFunction()) {
                  outs() << "      " << CUFunc->getName() << "()\n";
                  // record that CUFunc is vulnerable
                  if (find(vulnerableVendorFuncs.begin(), vulnerableVendorFuncs.end(), CUFunc) == vulnerableVendorFuncs.end()) {
                    vulnerableVendorFuncs.push_back(CUFunc);
                  }
                }
              }
              CUs.erase(CUs.begin()+i); // remove CU from CUs
              goto outerloop;
            }
          }
        }
        outerloop:
        ;
      }
    }
  }
}

void VulnerabilityAnalysis::checkLeakedRights(Module& M, SandboxVector& sandboxes) {
  // TODO: also check if functions annotated as having a vulnerability run in a sandbox
  for (CallInst* C : pastVulnAnnotatedPoints) {
    // for each vulnerability, find out whether it is in a sandbox or not 
    // and what the leaked rights are
    /*dbgs() << "   past vuln annot point: ";
    C->dump();*/
    Function* F = C->getParent()->getParent();
    if (GlobalVariable* CVEGlobal = dyn_cast<GlobalVariable>(C->getArgOperand(0)->stripPointerCasts())) {
      ConstantDataArray* CVEGlobalArr = dyn_cast<ConstantDataArray>(CVEGlobal->getInitializer());
      StringRef CVE = CVEGlobalArr->getAsCString();
      DEBUG(dbgs() << "Enclosing function is " << F->getName() << "\n");

      for (Sandbox* S : sandboxes) {
        FunctionVector sandboxedFuncs = S->getFunctions();
        Function* entryPoint = S->getEntryPoint();
        if (find(sandboxedFuncs.begin(), sandboxedFuncs.end(), F) != sandboxedFuncs.end()) {
          outs() << "\n";
          outs() << " *** Sandboxed function \"" << F->getName() << "\" has a past-vulnerability annotation for \"" << CVE << "\".\n";
          outs() << " *** Another vulnerability here would not grant ambient authority to the attacker but would leak the following restricted rights:\n"     ;
          // F may run in a sandbox
          // find out what was passed into the sandbox (shared global variables, file descriptors)

          DEBUG(dbgs() << "Checking leaking of global variables\n");
          GlobalVariableIntMap varToPerms = S->getGlobalVarPerms();
          for (pair<GlobalVariable*,int> varPermPair : varToPerms) {
            GlobalVariable* G = varPermPair.first;
            int varPerms = varPermPair.second;
            StringRef varPermsStr = "";
            if (varPerms == (VAR_READ_MASK | VAR_WRITE_MASK)) {
              varPermsStr = "Read and write";
            }
            else if (varPerms & VAR_READ_MASK) {
              varPermsStr = "Read";
            }
            else if (varPerms) {
              varPermsStr = "Write";
            }
            if (varPermsStr != "") {
              outs () << " +++ " << varPermsStr << " access to global variable \"" << G->getName() << "\"\n";
            }
          }
          
          DEBUG(dbgs() << "Checking leaking of capabilities\n");
          ValueIntMap caps = S->getCapabilities();
          for (pair<const Value*,int> cap : caps) {
            const Argument* capArg = dyn_cast<const Argument>(cap.first);
            int capPerms = cap.second;
            StringRef capPermsStr = "";
            if (capPerms == (FD_READ_MASK | FD_WRITE_MASK)) {
              capPermsStr = "Read and write";
            }
            else if (capPerms & FD_READ_MASK) {
              capPermsStr = "Read";
            }
            else if (capPerms) {
              capPermsStr = "Write";
            }
            if (capPermsStr != "") {
              outs() << " +++ " << capPermsStr << " access to file descriptor \"" << capArg->getName() << "\" passed into sandbox entrypoint \"" << entryPoint->getName() << "\"\n";
            }
          }
        }
      }
      if (find(privilegedFuncs.begin(), privilegedFuncs.end(), F) != privilegedFuncs.end()) {
        // F may run with ambient authority
        outs() << "\n";
        outs() << " *** Function \"" << F->getName() << "\" has a past-vulnerability annotation for \"" << CVE << "\".\n";
        outs() << " *** Another vulnerability here would leak ambient authority to the attacker including full\n";
        outs() << " *** network and file system access.\n"; 
        outs() << " Possible trace:\n";
        PrettyPrinters::ppPrivilegedPathToFunction(F, M);
        outs() << "\n\n";
      }
    }

  }
  for (Function* P : privilegedFuncs) {
    if (find(pastVulnAnnotatedFuncs.begin(), pastVulnAnnotatedFuncs.end(), P) != pastVulnAnnotatedFuncs.end()) {
      string CVE = pastVulnAnnotatedFuncToCVE[P];
      // enclosingFunc may run with ambient authority
      outs() << "\n";
      outs() << " *** Function " << P->getName() << " has a past-vulnerability annotation for " << CVE << ".\n";
      outs() << " *** Another vulnerability here would leak ambient authority to the attacker including full\n";
      outs() << " *** network and file system access.\n"; 
      outs() << " Possible trace:\n";
      PrettyPrinters::ppPrivilegedPathToFunction(P, M);
    }
  }

}
